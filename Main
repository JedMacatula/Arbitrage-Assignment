// Jed Macatula
// 5/31/16
// calculate a profit utilizing combinations of exchange rates

#include<iostream>
#include<vector>
#include<iomanip>
#include<fstream>
#include<algorithm>
#include<iterator>
#include<functional>

using namespace std;

// Function provided by Instructor
template< class I, class O >																			// I forward, O bidirectional iterator
I next_subset(I uni_first, I uni_last,																	// set universe in a range
	O sub_first, O sub_last) {																			// current subset in a range
	std::pair< O, I > mis = std::mismatch(sub_first, sub_last, uni_first);
	if (mis.second == uni_last) return sub_first;														// finished cycle

	typedef std::reverse_iterator<O> RO;
	mis.first = std::find_if(RO(mis.first), RO(sub_first), std::bind1st(
		std::not_equal_to< typename std::iterator_traits<O>::value_type >(),
		*mis.second)).base();																			// move mis.first before identical grouping

	O ret;
	if (mis.first != sub_first) {																		// copy elements after mismatch
		ret = std::copy(mis.first, sub_last, ++O(sub_first));
	}
	else std::copy_backward(mis.first, sub_last, ++(ret = sub_last));

	*sub_first = *mis.second;																			// add first element not yet in result
	return ret;
}

vector <vector <double>> makeTable(int mySizeOfTable, vector <double> myPushVector, vector <vector <double>> myTable, ifstream &myIns) // Time Analysis: O(n^3) Space Analysis: O(1)
{																																	   // Precondition: myIns.good() == true && mySizeOfTable >= 2 Postcondition: myIns >> myTable
	double fromFile;

	for (int i = 0; i < mySizeOfTable; i++)																//pushes vector of NULLs onto table (vector of vectors)
	{
		for (int j = 0; j < mySizeOfTable; j++)
		{
			myPushVector.push_back(NULL);
		}
		myTable.push_back(myPushVector);
	}

	for (int i = 0; i < mySizeOfTable; i++)																//makes the main diagnal of the table 1.00
	{
		myTable[i][i] = 1.00;
	}

	for (int i = 0; i < mySizeOfTable; i++)																//reads data from file and puts it in the table if the current position is equal to NULL
	{
		for (int j = 0; j < mySizeOfTable; j++)
		{
			if (myTable[i][j] != 1)
			{
				myIns >> fromFile;
				myTable[i][j] = fromFile;
			}
		}
	}

	return myTable;
}

void printOrder(vector < int > myVector)																// Time Analysis: O(n) Space Analysis: O(1)
{																										// Precondition: Postcondition: displays the numbers that represent the countries
	for (int i = 0; i < (myVector.size() - 1); i++)
	{
		cout << myVector[i] + 1 << " ";
	}

	cout << myVector[myVector.size() - 1] + 1;
}

double calculateMax(vector <vector <double>> myTable, vector < int > myVector, double myMax)			// Time Analysis: O(n) Space Analysis: O(1)
{																										// Precondition: myMax >= 1.00 Postcondition: returns a double value which will be set to be the new max for
	double max = 1.00;																					//				                              which a comparison will be made for the next subset/combination

	for (int i = 0; i < (myVector.size() - 1); i++)														// myVector is the vector generated by next_subset which consists of the numbers that represent the different countries
	{																									// iterates through the vector and uses those numbers that represent the countries as the coordinates of the table
		max = max * myTable[myVector[i]][myVector[i + 1]];												// calculates the max
	}

	if (max > myMax)																					// if the max of this subset/combination is greater than the current overall max, this max is returned
	{
		return max;
	}
	else                                                                                                // returns original current overall max if the calculated max isn't greater than the current overall max
	{
		return myMax;
	}
}

int main()																								// Time Analysis: O(n^4) Space Analysis: O(n^3)
{																										// Precondition: ins.open("input.txt") == good Postcondition: prints the largest profit from each table along with the 
	ifstream ins;																						//                                                            list of countries to be exchanged with to get that profit
	ins.open("input.txt");
	int numberOfTables, sizeOfTable;
	double currentOverallMax;
	double MAX = 1.00;																					// chosen max because that is the starting amount
	vector <vector <double>> table;
	vector <double> pushVector;
	vector <int> MAXCountryOrder;

	ins >> numberOfTables;

	while (ins >> sizeOfTable)																			// loops to do functions on tables until there is no more to read from the file
	{
		table = makeTable(sizeOfTable, pushVector, table, ins);

		do                                                                                              // loop for all subsets/combinations of countries
		{
			currentOverallMax = calculateMax(table, vectorOfCountries, currentOverallMax);
			if (currentOverallMax > MAX)
			{
				MAX = currentOverallMax;
				MAXCountryOrder = vectorOfCountries;
			}

		} while (next_subset(vectorOfCountries));

		cout << fixed << showpoint << setprecision(2) << MAX << " ";
		printOrder(MAXCountryOrder);
		cout << endl;

		table.clear();
	}

	/*
	int max = 1;
	int check = 1;

	int myNumbers[] = { 1, 2, 3, 4, 5 };																<<<<<<< program would probably work if a vector could be passed into the function instead of an array
	vector< int > numbers(myNumbers, myNumbers + sizeof myNumbers / sizeof *myNumbers);
	vector< int > subNumbers(numbers.size());
	vector< int >::iterator lastNumber = subNumbers.begin();

	while ((lastNumber = next_subset(numbers.begin(), numbers.end(), subNumbers.begin(), lastNumber)) != subNumbers.begin())
	{
	cerr << "size " << lastNumber - subNumbers.begin() << ": ";

	for (vector<int>::iterator fit = subNumbers.begin(); fit != lastNumber; ++fit)
	{
	cerr << *fit << " ";
	check = check * *fit;
	}
	if (check > max)
	{
	max = check;
	}
	cout << "         total: " << check << endl;
	check = 1;
	}

	cout << "Max: " << max << endl;
	*/

	system("pause");
	return 0;
}
